import { initErrorManager } from "./errorManager.js";
import {
  applyEnvironment, setWorldSize, createAdamAndEve, step as entitiesStep
} from "./entities.js";
import { step as reproductionStep, setMutationRate } from "./reproduction.js";
import { step as foodStep, setSpawnRate } from "./food.js";
import { draw, setPerfMode as rendererPerf } from "./renderer.js";
import { openEditor } from "./editor.js";
import { openEnvPanel, getEnvState } from "./environment.js";
import { initTicker, setPerfMode as tickerPerf, pushFrame, setSpeedIndicator } from "./ticker.js";

let running = false;
let timescale = 1;
let perfMode = false;

const SPEED_STEPS = [1, 5, 10, 50];
let speedIdx = 0;

let lastTime = 0, acc = 0;
const fixedDt = 1 / 60;
let simTime = 0;

/** Canvas-Größe & Topbar-Abstand aktualisieren */
function resizeCanvas() {
  const canvas = document.getElementById("world");
  const topbar = document.getElementById("topbar");

  if (topbar) {
    const h = topbar.offsetHeight || 56;
    document.documentElement.style.setProperty("--topbar-h", h + "px");
  }

  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.round(rect.width);
  canvas.height = Math.round(rect.height);
  setWorldSize(canvas.width, canvas.height);
}

/** UI-Bindings */
function bindUI() {
  document.getElementById("btnStart").onclick = start;
  document.getElementById("btnPause").onclick = pause;
  document.getElementById("btnReset").onclick = reset;
  document.getElementById("btnEditor").onclick = openEditor;
  document.getElementById("btnEnv").onclick = openEnvPanel;

  const mu = document.getElementById("mutation");
  mu.oninput = () => setMutationRate(parseFloat(mu.value));

  const fr = document.getElementById("foodrate");
  fr.oninput = () => setSpawnRate(parseFloat(fr.value));

  const pm = document.getElementById("perfmode");
  pm.oninput = () => setPerfMode(pm.checked);

  const sp = document.getElementById("btnSpeed");
  sp.onclick = () => cycleSpeed();

  setMutationRate(parseFloat(mu.value));
  setSpawnRate(parseFloat(fr.value));
  setPerfMode(pm.checked);
  setTimescale(SPEED_STEPS[speedIdx]);
  updateSpeedButton();
}

function updateSpeedButton(){
  const sp = document.getElementById("btnSpeed");
  if (sp) sp.textContent = `Tempo ×${SPEED_STEPS[speedIdx]}`;
}
function cycleSpeed(){
  speedIdx = (speedIdx + 1) % SPEED_STEPS.length;
  setTimescale(SPEED_STEPS[speedIdx]);
  updateSpeedButton();
}

/** Render-Loop (fixed updates + draw), ohne Promises */
function frame(now) {
  if (!running) return;
  now /= 1000;

  if (!lastTime) lastTime = now;
  let delta = Math.min(0.1, now - lastTime);
  lastTime = now;

  acc += delta * timescale;

  const desiredSteps = Math.floor(acc / fixedDt);
  const maxSteps = Math.min(60, Math.max(8, Math.ceil(timescale * 1.2)));

  const steps = Math.min(desiredSteps, maxSteps);
  const env = getEnvState();

  for (let s = 0; s < steps; s++) {
    entitiesStep(fixedDt, env, simTime);
    reproductionStep(fixedDt);
    foodStep(fixedDt);
    simTime += fixedDt;
    acc -= fixedDt;
  }

  if (Math.floor(acc / fixedDt) > maxSteps) {
    acc = fixedDt * maxSteps;
  }

  draw();
  pushFrame(fixedDt, 1 / delta);
  requestAnimationFrame(frame);
}

/** Public API */
export function boot() {
  initErrorManager();
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  createAdamAndEve();
  applyEnvironment(getEnvState());

  initTicker();
  bindUI();
  draw();
}
export function start(){ if (!running) { running = true; lastTime = 0; requestAnimationFrame(frame); } }
export function pause(){ running = false; }
export function reset(){
  running = false;
  import("./food.js").then(m => m.spawnClusters());
  import("./entities.js").then(m => { m.createAdamAndEve(); });
  draw();
}
export function setTimescale(x){
  timescale = Math.max(0.1, Math.min(50, x));
  setSpeedIndicator(timescale);
}
export function setPerfMode(on){
  perfMode = !!on;
  rendererPerf(perfMode);
  tickerPerf(perfMode);
}
window.addEventListener("DOMContentLoaded", boot);